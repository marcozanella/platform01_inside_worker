# Implementation Plan: SQL Server Sync Worker

**Branch**: `002-sqlserver-sync-worker` | **Date**: 2025-12-14 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-sqlserver-sync-worker/spec.md`

**Note**: This plan follows the speckit.plan workflow. Research phase (Phase 0) and design phase (Phase 1) outputs are generated by this command.

## Summary

Create a recurring background job that connects to SAP SQL Server every 5 minutes, fetches all records from the vwZSDOrder_Advanced view, and syncs them to the local open_orders table using batch processing (500 records per batch). The job uses explicit column mapping configuration, maintains data integrity through transactions, and keeps old data visible if sync fails.

**Technical Approach**: Use Solid Queue recurring jobs with TinyTDS gem for SQL Server connectivity, batch inserts for performance, explicit column mapping for reliability, and comprehensive error handling with logging.

## Technical Context

**Language/Version**: Ruby 3.3.5 / Rails 8.1.1 (per constitution)  
**Primary Dependencies**:
- **tinytds** (~> 2.1) - SQL Server adapter for Ruby
- **activerecord-sqlserver-adapter** (~> 7.2) - ActiveRecord adapter for SQL Server
- **solid_queue** (already configured) - Background job processing
- **kaminari** (already installed) - Not used in this feature but available

**Storage**: 
- SQLite3 (local open_orders table) - per constitution
- SQL Server (external source: CASQL2.inxintl.com) - read-only access to vwZSDOrder_Advanced view

**Testing**: None (per constitution - manual validation only)

**Target Platform**: Linux server (Docker via Kamal) - per constitution

**Project Type**: Rails worker application (background job processing)

**Performance Goals**: 
- Sync completes within 5 minutes for datasets up to 5,000 records
- Batch processing at 500 records per batch
- Sync runs every 5 minutes (12 times per hour)
- Connection timeout: 30 seconds
- Transaction timeout: 5 minutes

**Constraints**: 
- Application runs in firewalled network (credentials in config/database.yml acceptable)
- Expected dataset size: <5,000 records (current reality based on business volume)
- Must not run concurrent syncs (prevent overlapping executions)
- Must preserve old data if sync fails (no partial updates)
- 70+ fields must be explicitly mapped from SQL Server columns to Rails attributes

**Scale/Scope**: 
- Single recurring job running every 5 minutes
- Expected 12 executions per hour, ~288 per day
- Dataset size: <5,000 records per sync (typical ~1,500-3,000 records)
- Network: Firewalled environment, SQL Server on internal network

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- [X] **Rails Conventions First**: ✅ Uses Rails generators for job creation, follows Rails naming (SyncOpenOrdersJob), uses ActiveRecord for data access, standard service objects pattern
- [X] **Background Job Architecture**: ✅ Core functionality is a Solid Queue recurring job, idempotent design (truncate + insert in transaction), comprehensive logging, retryable on failure
- [X] **Simplicity Over Optimization**: ✅ Simple batch insert strategy, direct SQL Server queries (no complex streaming), explicit column mapping (no abstraction layers), uses Rails conventions throughout
- [X] **Admin-Only Operations**: ✅ No user-facing UI, system-to-system only (scheduled job), existing admin interface shows sync status via last sync timestamp
- [X] **Modern Rails Stack**: ✅ Uses Solid Queue for job scheduling, TinyTDS is standard SQL Server adapter, no Redis or external dependencies

*No violations - design fully compliant with constitution.*

## Project Structure

### Documentation (this feature)

```text
specs/002-sqlserver-sync-worker/
├── plan.md              # This file (implementation plan)
├── research.md          # Phase 0 output (TinyTDS, batch strategies, column mapping)
├── data-model.md        # Phase 1 output (column mapping configuration)
├── quickstart.md        # Phase 1 output (setup and testing guide)
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
# Rails 8 Application Structure
app/
├── models/
│   └── open_order.rb          # Existing model (no changes needed)
├── jobs/
│   └── sync_open_orders_job.rb # New: Main recurring job
├── services/
│   ├── sql_server_connector.rb # New: Handles SQL Server connection
│   └── open_orders_importer.rb # New: Batch import logic with column mapping
└── helpers/
    └── open_orders_helper.rb   # Existing (no changes)

config/
├── database.yml               # Modified: Add sqlserver connection config
├── recurring.yml              # Modified: Add job schedule (every 5 minutes)
└── routes.rb                  # No changes

db/
├── migrate/                   # No new migrations needed
└── schema.rb                  # No changes (open_orders table exists)

lib/
└── tasks/
    └── sync.rake              # New: Manual sync task for testing

Gemfile                        # Modified: Add tinytds, activerecord-sqlserver-adapter
```

**Structure Decision**: Standard Rails 8 structure with focus on app/jobs/ for the recurring job. Services encapsulate SQL Server connection logic and batch import logic with explicit column mapping. No new models or migrations needed since open_orders table already exists. Manual rake task provides testing/troubleshooting capability.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

*No violations - this section intentionally left empty.*

---

## Phase 0: Research & Unknowns Resolution

**Goal**: Resolve all NEEDS CLARIFICATION items and research technical unknowns before design begins.

### Research Tasks

1. **TinyTDS Connection Setup**
   - Research: How to configure TinyTDS with FreeTDS for SQL Server connections on Linux
   - Research: Required database.yml configuration for SQL Server connection
   - Research: Connection timeout and retry strategies
   - Output: Document connection configuration in research.md

2. **Column Mapping Strategy**
   - Research: Identify actual column names in vwZSDOrder_Advanced view (may differ from OpenOrder attributes)
   - Research: Best practices for explicit column mapping in Rails (hash mapping vs service object)
   - Research: How to handle missing/extra columns gracefully
   - Output: Document mapping approach and column name differences in research.md

3. **Batch Processing with ActiveRecord**
   - Research: ActiveRecord.insert_all vs manual batch inserts for 500-record batches
   - Research: Transaction handling with truncate + batch inserts
   - Research: Memory management for <5,000 record datasets
   - Output: Document recommended batch strategy in research.md

4. **Solid Queue Recurring Job Configuration**
   - Research: config/recurring.yml syntax for 5-minute intervals
   - Research: How to prevent concurrent job executions (Solid Queue locking)
   - Research: Job retry strategies and error handling
   - Output: Document job configuration in research.md

5. **SQL Server Query Performance**
   - Research: Optimal SQL query for fetching all records from vwZSDOrder_Advanced
   - Research: Whether to use SELECT * or explicit column list
   - Research: Connection pooling considerations
   - Output: Document query approach in research.md

**Consolidation**: All research findings documented in `research.md` with:
- Decision: What approach was chosen
- Rationale: Why chosen over alternatives
- Alternatives considered: What else was evaluated

---

## Phase 1: Design & Contracts

**Prerequisites**: research.md complete

**Goal**: Create data model, column mapping configuration, and implementation guide.

### Deliverables

1. **data-model.md**
   - Column mapping configuration: SQL Server column → OpenOrder attribute mapping for all 70+ fields
   - Data type conversions: String → Integer, DateTime parsing, NULL handling
   - Validation rules: Any data constraints from OpenOrder model
   - Transaction flow: Fetch → Validate → Truncate → Insert sequence

2. **quickstart.md**
   - Setup guide: Installing tinytds gem, configuring database.yml
   - Testing guide: Running manual sync via rake task
   - Troubleshooting: Common connection errors, credential issues
   - Monitoring: Where to check logs, how to verify sync status

3. **Agent Context Update**
   - Run `.specify/scripts/bash/update-agent-context.sh copilot`
   - Add TinyTDS and SQL Server patterns to agent context
   - Preserve manual additions between markers

**Output**: data-model.md, quickstart.md, updated agent context file

---

## Phase 2: Implementation Tasks

**Prerequisites**: Phase 1 complete, constitution re-checked

**Goal**: Generate detailed implementation tasks using `/speckit.tasks` command.

**Process**:
1. Run `/speckit.tasks` to generate tasks.md
2. Tasks will be organized by user story priority (P1, P2, etc.)
3. Each task will include file paths and acceptance criteria
4. Tasks will be marked for sequential or parallel execution

**Note**: This phase is executed by a separate command (`/speckit.tasks`), not by `/speckit.plan`.

---

## Key Implementation Notes

### Critical Path
1. **Setup (blocking)**: Add gems, configure database.yml with SQL Server connection
2. **Column Mapping (blocking)**: Must map all 70+ fields correctly before import can work
3. **Job Implementation**: SyncOpenOrdersJob with service objects for connection and import
4. **Recurring Schedule**: Configure recurring.yml for 5-minute execution
5. **Testing**: Manual verification with real SQL Server data

### Risk Mitigation
- **Connection Failures**: Implement retry logic with exponential backoff, don't truncate on connection failure
- **Partial Imports**: Use database transactions, rollback on any error
- **Concurrent Executions**: Rely on Solid Queue's built-in job locking
- **Column Mismatches**: Explicit mapping catches missing columns early, log warnings for extra columns

### Performance Considerations
- Batch size of 500 records balances memory usage and database round-trips
- Expected <5,000 records should complete in <2 minutes typically
- 5-minute interval provides buffer for occasional slow syncs
- Transaction ensures all-or-nothing update (no partial state)

### Monitoring & Observability
- Log every sync attempt with timestamp, record count, duration
- Log errors with full exception details (masked credentials)
- Update OpenOrder.maximum(:updated_at) for sync timestamp visibility
- Solid Queue dashboard shows job execution history

---

## Constitution Re-Check (Post-Design)

*Re-evaluated on 2025-12-14 after Phase 1 design completion:*

- [X] **Rails Conventions First**: ✅ VALIDATED
  - data-model.md uses standard ActiveRecord patterns (insert_all, transaction blocks)
  - Column mapping follows Ruby naming conventions (snake_case symbols)
  - Service objects follow Rails patterns (class methods, explicit dependencies)
  - No custom DSLs or abstractions introduced

- [X] **Background Job Architecture**: ✅ VALIDATED
  - Job design is idempotent (fetch → transaction → truncate → insert)
  - Error handling preserves old data if sync fails (fetch outside transaction)
  - Comprehensive logging documented in quickstart.md (info, warn, error levels)
  - Solid Queue recurring.yml configuration prevents concurrent executions automatically

- [X] **Simplicity Over Optimization**: ✅ VALIDATED
  - Batch processing uses simple insert_all with 500-record batches
  - Explicit hash-based column mapping (COLUMN_MAPPING constant)
  - Direct TinyTDS queries (no complex ORM abstractions)
  - Type conversion uses simple case statements (no metaprogramming)
  - No caching, streaming, or premature optimization

- [X] **Admin-Only Operations**: ✅ VALIDATED
  - No UI components added in design phase
  - Status visibility via existing OpenOrder.maximum(:updated_at) timestamp
  - Manual testing via rake task (documented in quickstart.md)
  - System-to-system only (scheduled job, no user interaction)

- [X] **Modern Rails Stack**: ✅ VALIDATED
  - Solid Queue for recurring job scheduling (config/recurring.yml)
  - TinyTDS gem (standard SQL Server adapter, no Redis)
  - No additional external dependencies beyond TinyTDS and FreeTDS
  - Deployment via existing Kamal configuration (Dockerfile updated only)

**Post-Design Verdict**: ✅ ALL PRINCIPLES VALIDATED - Design remains fully compliant with constitution. No violations or exceptions needed.

**Phase 1 Complete**: data-model.md (67 field mapping), quickstart.md (setup guide), agent context updated. Ready for Phase 2 (tasks generation via /speckit.tasks command).
